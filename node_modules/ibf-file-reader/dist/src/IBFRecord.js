"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * IBFRecord is a simple holder for the unprocessed bytes of a single IBF record from a file.
 */
class IBFRecord {
    constructor(buffer) {
        this.buffer = buffer;
    }
    getBuffer() {
        return this.buffer;
    }
    iterator() {
        return new IBFRecordIterator(this.buffer);
    }
}
exports.IBFRecord = IBFRecord;
class Version {
    constructor(major, minor, patch) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
    }
}
exports.Version = Version;
class IBFRecordIterator {
    constructor(buffer) {
        this.buffer = buffer;
        this.offset = 0;
    }
    remaining() {
        return this.buffer.length - this.offset;
    }
    skip(n) {
        this.offset += n;
    }
    nextInt8() {
        let value = this.buffer.readInt8(this.offset);
        this.offset += 1;
        return value;
    }
    nextUInt16LE() {
        let value = this.buffer.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
    }
    nextUInt16BE() {
        let value = this.buffer.readUInt16BE(this.offset);
        this.offset += 2;
        return value;
    }
    nextInt16LE() {
        let value = this.buffer.readInt16LE(this.offset);
        this.offset += 2;
        return value;
    }
    nextInt16BE() {
        let value = this.buffer.readInt16BE(this.offset);
        this.offset += 2;
        return value;
    }
    nextUInt32LE() {
        let value = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
    }
    nextUInt32BE() {
        let value = this.buffer.readUInt32BE(this.offset);
        this.offset += 4;
        return value;
    }
    nextInt32LE() {
        let value = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return value;
    }
    nextInt32BE() {
        let value = this.buffer.readInt32BE(this.offset);
        this.offset += 4;
        return value;
    }
    nextDate() {
        if (this.remaining() < 7) {
            return null;
        }
        let day = this.nextInt8();
        let month = this.nextInt8();
        let year = this.nextUInt16LE();
        let seconds = this.nextInt8();
        let minutes = this.nextInt8();
        let hours = this.nextInt8();
        return new Date(year, month - 1, day, hours, minutes, seconds);
    }
    nextVersion() {
        if (this.remaining() < 3) {
            return null;
        }
        let major = this.nextInt8();
        let minor = this.nextInt8();
        let patch = this.nextInt8();
        return new Version(major, minor, patch);
    }
    nextString(maxLength) {
        let idx = this.offset;
        while (this.buffer[idx] != 0x00) {
            idx++;
        }
        let strBuffer = this.buffer.slice(this.offset, idx);
        this.offset += maxLength;
        return strBuffer.toString('latin1');
    }
}
exports.IBFRecordIterator = IBFRecordIterator;
class IBFRecordReader {
    /*
     * Attempts to read a single IBFRecord from the start of the given buffer.
     *
     * Returns the IBFRecord and a slice of the buffer containing the unread bytes.
     *
     * Returns [null, buffer] if there are insufficient bytes to read another IBFRecord.
     *
     * Throws an Error if the checksum does not match the read data.
     */
    read(buffer) {
        let remainingBytes = buffer.length;
        if (remainingBytes < 4) {
            return [null, buffer];
        }
        let recordSize = buffer.readUInt16BE(0);
        if (remainingBytes < recordSize + 2) {
            return [null, buffer];
        }
        let data = buffer.slice(2, recordSize);
        let checksum = new Int32Array(1);
        data.forEach(value => {
            checksum[0] += (value & 0xff);
        });
        let expectedChecksum = buffer.readUInt16BE(recordSize);
        if (checksum[0] != expectedChecksum) {
            let loggedData = [
                'expectedChecksum = ' + expectedChecksum,
                'actualChecksum = ' + checksum,
                'recordSize = ' + recordSize,
                'bytes = ' + data.toString('hex')
            ];
            throw Error('IBFIntegrityException: checksum(' + loggedData.join(", ") + ')');
        }
        return [new IBFRecord(data), buffer.slice(recordSize + 2, buffer.length)];
    }
}
exports.IBFRecordReader = IBFRecordReader;
//# sourceMappingURL=IBFRecord.js.map